---
phase: 01-foundation
plan: 02
type: tdd
wave: 2
depends_on:
  - "01-01"
files_modified:
  - src/client/WLEDClient.ts
  - src/client/types.ts
  - src/client/__tests__/WLEDClient.test.ts
autonomous: true
requirements:
  - UI-03

must_haves:
  truths:
    - "WLEDClient can fetch device info from a WLED controller via HTTP"
    - "WLEDClient can send state changes to a WLED controller via HTTP POST"
    - "WLEDClient times out cleanly on unreachable controllers without freezing"
    - "WLEDClient correctly parses host:port format with default port 80"
  artifacts:
    - path: "src/client/WLEDClient.ts"
      provides: "HTTP wrapper for WLED JSON API with AbortSignal timeouts"
      exports: ["WLEDClient"]
    - path: "src/client/types.ts"
      provides: "TypeScript interfaces for WLED API responses"
      exports: ["WLEDInfo", "WLEDState"]
    - path: "src/client/__tests__/WLEDClient.test.ts"
      provides: "Unit tests for WLEDClient"
      contains: "describe.*WLEDClient"
  key_links:
    - from: "src/client/WLEDClient.ts"
      to: "WLED HTTP API"
      via: "fetch() with AbortSignal.timeout()"
      pattern: "AbortSignal\\.timeout"
    - from: "src/client/WLEDClient.ts"
      to: "src/client/types.ts"
      via: "type imports"
      pattern: "import.*types"
---

<objective>
Build the WLEDClient HTTP wrapper that communicates with WLED devices via the JSON API, with AbortSignal timeouts on every request to prevent plugin freezes.

Purpose: Every action in Phase 2+ needs to send HTTP requests to WLED. This client is the single interface for all WLED communication, with built-in timeout safety.
Output: A tested WLEDClient class and WLED type definitions.
</objective>

<execution_context>
@C:/Users/barlo/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/barlo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create WLED types and WLEDClient with TDD</name>
  <files>
    src/client/types.ts
    src/client/WLEDClient.ts
    src/client/__tests__/WLEDClient.test.ts
    package.json
  </files>
  <action>
    First, install test dependencies if not present: `vitest` as devDependency. Add a `"test"` script to package.json: `"test": "vitest run"`. Add vitest config (can be inline in `vite.config.ts` or `vitest.config.ts`).

    **src/client/types.ts** — Define TypeScript interfaces:
    ```typescript
    export interface WLEDInfo {
      ver: string;       // firmware version
      name: string;      // device friendly name
      udpport: number;
      live: boolean;
      fxcount: number;
      palcount: number;
      // Add other commonly used fields as needed
    }

    export interface WLEDState {
      on: boolean;       // power on/off
      bri: number;       // brightness 0-255
      ps: number;        // current preset (-1 for none)
      // Add seg[], fx, sx etc. as needed for Phase 2+
    }
    ```

    **TDD RED phase** — Write tests first in `src/client/__tests__/WLEDClient.test.ts`:

    Test cases (mock `fetch` globally):
    1. `getInfo()` — fetches `/json/info` and returns parsed WLEDInfo
    2. `getInfo()` — throws on non-200 response
    3. `getInfo()` — throws on timeout (simulate AbortSignal.timeout behavior)
    4. `getState()` — fetches `/json/state` and returns parsed WLEDState
    5. `setState()` — POSTs to `/json/state` with JSON body and correct Content-Type header
    6. `setState()` — throws on non-200 response
    7. `isOnline()` — returns true when getInfo succeeds, false when it throws
    8. `fromHostPort()` static factory — parses "192.168.1.50" to `http://192.168.1.50:80`, "192.168.1.50:8080" to `http://192.168.1.50:8080`

    Use `vi.stubGlobal('fetch', ...)` or `vi.fn()` to mock fetch.

    Run tests — they should ALL FAIL (red phase).

    **TDD GREEN phase** — Implement `src/client/WLEDClient.ts`:

    ```typescript
    export class WLEDClient {
      private readonly baseUrl: string;

      constructor(baseUrl: string) {
        this.baseUrl = baseUrl.replace(/\/$/, '');
      }

      static fromHostPort(hostPort: string): WLEDClient {
        // Parse "host:port" or "host" (default port 80)
        // Use parseHostPort helper from RESEARCH.md
        const { host, port } = parseHostPort(hostPort);
        return new WLEDClient(`http://${host}:${port}`);
      }

      async getInfo(timeoutMs = 1500): Promise<WLEDInfo> {
        const response = await fetch(`${this.baseUrl}/json/info`, {
          signal: AbortSignal.timeout(timeoutMs),
        });
        if (!response.ok) throw new Error(`WLED HTTP ${response.status}`);
        return response.json() as Promise<WLEDInfo>;
      }

      async getState(timeoutMs = 1500): Promise<WLEDState> {
        const response = await fetch(`${this.baseUrl}/json/state`, {
          signal: AbortSignal.timeout(timeoutMs),
        });
        if (!response.ok) throw new Error(`WLED HTTP ${response.status}`);
        return response.json() as Promise<WLEDState>;
      }

      async setState(patch: Partial<WLEDState>, timeoutMs = 1500): Promise<void> {
        const response = await fetch(`${this.baseUrl}/json/state`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(patch),
          signal: AbortSignal.timeout(timeoutMs),
        });
        if (!response.ok) throw new Error(`WLED HTTP ${response.status}`);
      }

      async isOnline(timeoutMs = 500): Promise<boolean> {
        try {
          await this.getInfo(timeoutMs);
          return true;
        } catch {
          return false;
        }
      }
    }
    ```

    Include the `parseHostPort` helper (can be a private function or exported utility):
    ```typescript
    function parseHostPort(input: string, defaultPort = 80): { host: string; port: number } {
      const lastColon = input.lastIndexOf(':');
      if (lastColon > -1 && !input.startsWith('[')) {
        const maybePort = parseInt(input.slice(lastColon + 1), 10);
        if (!isNaN(maybePort) && maybePort > 0 && maybePort <= 65535) {
          return { host: input.slice(0, lastColon), port: maybePort };
        }
      }
      return { host: input, port: defaultPort };
    }
    ```

    Run tests — they should ALL PASS (green phase).

    **REFACTOR phase** — Clean up if needed. Ensure exports are clean. Run tests again.
  </action>
  <verify>
    1. `npm test` passes all WLEDClient tests (8 test cases)
    2. `npm run build` still compiles without errors
    3. `src/client/WLEDClient.ts` exports `WLEDClient` class
    4. `src/client/types.ts` exports `WLEDInfo` and `WLEDState` interfaces
    5. Every `fetch()` call in WLEDClient uses `AbortSignal.timeout()`
  </verify>
  <done>
    WLEDClient class is fully tested and handles: info fetching, state reading, state writing, online checking, host:port parsing, and timeout on all requests. All tests pass. Build succeeds.
  </done>
</task>

</tasks>

<verification>
- `npm test` exits with code 0, all tests green
- `npm run build` exits with code 0
- `grep -r "AbortSignal.timeout" src/client/WLEDClient.ts` returns matches for every fetch call
</verification>

<success_criteria>
WLEDClient is a tested, buildable HTTP wrapper for the WLED JSON API. Every fetch call has an AbortSignal timeout. The client correctly parses host:port inputs and provides getInfo, getState, setState, and isOnline methods.
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-02-SUMMARY.md`
</output>
