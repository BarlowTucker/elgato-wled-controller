---
phase: 01-foundation
plan: 03
type: execute
wave: 3
depends_on:
  - "01-01"
  - "01-02"
files_modified:
  - src/registry/types.ts
  - src/registry/ControllerRegistry.ts
  - src/discovery/MDNSScanner.ts
  - src/plugin.ts
  - ui/global-settings.html
  - manifest.json
autonomous: true
requirements:
  - CTRL-01
  - CTRL-02
  - CTRL-03
  - CTRL-06

must_haves:
  truths:
    - "User can add a WLED controller by IP/hostname and it persists across restarts"
    - "User can remove a controller from the global registry"
    - "Adding a controller auto-fetches the WLED device name"
    - "User can scan for WLED devices via mDNS and batch-add selected ones"
    - "Already-registered devices appear greyed out in scan results"
    - "Removing a controller shows a warning about existing action references"
    - "Offline controllers show an offline indicator in the controller list"
  artifacts:
    - path: "src/registry/types.ts"
      provides: "WLEDController and RegistryState interfaces"
      exports: ["WLEDController", "RegistryState"]
    - path: "src/registry/ControllerRegistry.ts"
      provides: "Singleton registry with CRUD and global settings persistence"
      exports: ["ControllerRegistry"]
    - path: "src/discovery/MDNSScanner.ts"
      provides: "mDNS PTR scan for _wled._tcp.local"
      exports: ["MDNSScanner", "DiscoveredDevice"]
    - path: "ui/global-settings.html"
      provides: "Global settings Property Inspector with scan, list, and add form"
      contains: "btn-scan"
    - path: "src/plugin.ts"
      provides: "Plugin entry point with registry load and PI message handling"
      contains: "ControllerRegistry"
  key_links:
    - from: "src/plugin.ts"
      to: "src/registry/ControllerRegistry.ts"
      via: "load() before connect(), message handler for PI"
      pattern: "ControllerRegistry\\.getInstance"
    - from: "src/plugin.ts"
      to: "src/discovery/MDNSScanner.ts"
      via: "scan handler invoked from PI message"
      pattern: "MDNSScanner|scanForWLED"
    - from: "src/registry/ControllerRegistry.ts"
      to: "streamDeck.settings"
      via: "setGlobalSettings/getGlobalSettings"
      pattern: "setGlobalSettings|getGlobalSettings"
    - from: "src/registry/ControllerRegistry.ts"
      to: "src/client/WLEDClient.ts"
      via: "auto-fetch device name on add"
      pattern: "WLEDClient.*getInfo|fetchDeviceName"
    - from: "ui/global-settings.html"
      to: "src/plugin.ts"
      via: "sendToPlugin/sendToPropertyInspector messages"
      pattern: "sendToPlugin|type.*addController|type.*scan"
---

<objective>
Build the ControllerRegistry singleton (CRUD + global settings persistence), mDNS scanner, and the global settings Property Inspector UI so users can manage their WLED controllers.

Purpose: This is the core infrastructure that all actions reference. Without a controller registry, no action knows which WLED devices to target.
Output: A working global settings panel where users can scan for devices, add/remove controllers, and see online/offline status. Controllers persist across Stream Deck restarts.
</objective>

<execution_context>
@C:/Users/barlo/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/barlo/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: ControllerRegistry singleton and mDNS scanner</name>
  <files>
    src/registry/types.ts
    src/registry/ControllerRegistry.ts
    src/discovery/MDNSScanner.ts
  </files>
  <action>
    **src/registry/types.ts** — Define interfaces:
    ```typescript
    export interface WLEDController {
      id: string;          // crypto.randomUUID() — stable identifier for action references
      ip: string;          // "192.168.1.50" or "192.168.1.50:8080"
      name: string;        // display name (auto-fetched from WLED or user-supplied)
      addedAt: number;     // Date.now() timestamp for ordering
    }

    export interface RegistryState {
      controllers: WLEDController[];
    }
    ```

    **src/registry/ControllerRegistry.ts** — Singleton with CRUD:

    Import `streamDeck` from `@elgato/streamdeck` and `WLEDClient` from `../client/WLEDClient`.

    Methods:
    - `static getInstance(): ControllerRegistry` — standard singleton
    - `async load(): Promise<void>` — reads `streamDeck.settings.getGlobalSettings<RegistryState>()` into `this.state`. If null/undefined, initialize to `{ controllers: [] }`.
    - `async add(ip: string, nameOverride?: string): Promise<WLEDController>` — Creates a new controller entry. Auto-fetches device name via `WLEDClient.fromHostPort(ip).getInfo()` in a try/catch (if offline, use nameOverride or ip as fallback name). Generates UUID with `crypto.randomUUID()`. Pushes to `this.state.controllers`. Calls `await this.save()`. Returns the new controller.
    - `async remove(id: string): Promise<void>` — Filters out controller by id. Calls `await this.save()`.
    - `getAll(): WLEDController[]` — returns copy of controllers array.
    - `getById(id: string): WLEDController | undefined` — find by id.
    - `has(ip: string): boolean` — check if IP already registered (for mDNS duplicate detection).
    - `private async save(): Promise<void>` — calls `streamDeck.settings.setGlobalSettings(this.state)`.

    Per locked decision: Save immediately on add — do NOT validate reachability first. The auto-name fetch is best-effort only.

    **src/discovery/MDNSScanner.ts** — mDNS scan:

    ```typescript
    import mdns from 'multicast-dns';

    export interface DiscoveredDevice {
      ip: string;
      name: string;
    }

    export class MDNSScanner {
      async scan(timeoutMs = 4000): Promise<DiscoveredDevice[]> {
        return new Promise((resolve) => {
          const m = mdns();
          const discovered = new Map<string, DiscoveredDevice>();

          const done = () => {
            m.destroy();
            resolve(Array.from(discovered.values()));
          };

          const timer = setTimeout(done, timeoutMs);

          m.on('response', (response) => {
            // Check both answers and additionals for A records (per RFC 6762)
            const aRecords = [
              ...response.answers.filter((r: any) => r.type === 'A'),
              ...response.additionals.filter((r: any) => r.type === 'A'),
            ];

            for (const record of aRecords) {
              const ip: string = record.data;
              if (!discovered.has(ip)) {
                const name = (record.name as string).replace(/\.local\.?$/, '');
                discovered.set(ip, { ip, name });
              }
            }
          });

          m.on('error', () => {
            clearTimeout(timer);
            done();
          });

          m.query({ questions: [{ name: '_wled._tcp.local', type: 'PTR' }] });
        });
      }
    }
    ```

    Ensure `m.destroy()` is always called (both in timeout and error handlers) to prevent UDP socket leaks per RESEARCH.md pitfall 3.
  </action>
  <verify>
    1. `npm run build` compiles without errors
    2. `ControllerRegistry` exports `getInstance`, `load`, `add`, `remove`, `getAll`, `getById`, `has` methods
    3. `MDNSScanner` exports `scan` method that returns `DiscoveredDevice[]`
    4. Every fetch in ControllerRegistry add flow uses WLEDClient (which has AbortSignal timeouts)
    5. `m.destroy()` is called in both the timeout and error handlers of MDNSScanner
  </verify>
  <done>
    ControllerRegistry singleton persists controllers via global settings, auto-fetches WLED names on add, and supports CRUD. MDNSScanner queries _wled._tcp.local and returns discovered devices with proper socket cleanup.
  </done>
</task>

<task type="auto">
  <name>Task 2: Global settings Property Inspector and plugin message wiring</name>
  <files>
    ui/global-settings.html
    src/plugin.ts
    manifest.json
  </files>
  <action>
    **ui/global-settings.html** — Global settings panel. Download `sdpi-components.js` from the Elgato SDK sample (or use the version bundled by `streamdeck create` scaffold if available) and place it in `ui/`. If the scaffold already created a PI directory structure, use that location.

    Layout per locked decisions (top to bottom):
    1. **Scan section (top)**: "Scan for Devices" button. When clicked, sends `{ type: 'scan' }` to plugin. While scanning, show "Scanning..." text, disable the button. On result, show discovered devices as a list with checkboxes. Already-registered devices appear greyed out with a checkmark — cannot be selected. "Add Selected" button to batch-add checked devices. If no devices found: show "No WLED devices found on your network. Try adding by IP below."
    2. **Controller list (middle)**: Rendered from `controllerList` messages. Each row shows: name, IP, online/offline indicator (text like "[Online]" / "[Offline]" — keep it simple within SD PI defaults), and a "Remove" button. Remove button sends `{ type: 'removeController', id: '...' }` to plugin. Include a small note below the list: "Removing a controller may affect actions that reference it."
    3. **Manual add form (bottom)**: IP/hostname text field (placeholder "192.168.1.50 or 192.168.1.50:8080"), optional name field (placeholder "Desk Strip"), and "Add Controller" button. Sends `{ type: 'addController', ip: '...', name: '...' }` to plugin. Clear form fields after successful add.

    Use standard SD PI styling via `sdpi-components.js` web components (`<sdpi-item>`, `<sdpi-button>`, `<sdpi-textfield>`). No custom CSS — match default Stream Deck look per locked decision.

    On page load: send `{ type: 'getControllers' }` to plugin to request current list.

    Listen for messages from plugin:
    - `{ type: 'controllerList', controllers: [...], onlineStatus: { [id]: boolean } }` — re-render controller list
    - `{ type: 'scanResults', devices: [...] }` — render scan results with checkboxes
    - `{ type: 'scanComplete' }` — re-enable scan button

    **src/plugin.ts** — Wire up PI message handling:

    After `ControllerRegistry.getInstance().load()` and before `streamDeck.connect()`:

    Subscribe to `streamDeck.settings.onDidReceiveGlobalSettings` to sync state changes.

    Handle PI messages (use `streamDeck.ui.onSendToPlugin` or the equivalent v2 API — check the actual export name at implementation time, per RESEARCH.md open question 1):

    Message handlers:
    - `getControllers`: Respond with controller list + online status. Check online status for each controller using `WLEDClient.fromHostPort(ip).isOnline()` with `Promise.allSettled()` for parallel checking. Send response via `sendToPropertyInspector`.
    - `addController`: Call `registry.add(ip, name)`. Then send updated controller list back.
    - `removeController`: Call `registry.remove(id)`. Then send updated controller list back.
    - `scan`: Create `MDNSScanner`, call `scan()`, send results back as `scanResults`. Then send `scanComplete`.
    - `addDiscovered`: Receive array of `{ ip, name }`, call `registry.add()` for each. Send updated controller list back.

    Background polling (Claude's discretion): Set up a `setInterval` at 30 seconds that checks online status of all controllers and pushes updates to any open PI. This is optional — the PI already requests status on open. If implemented, only run when the global settings panel is open (track via `streamDeck.ui.onSendToPlugin` receiving a `getControllers` message as a proxy for "panel opened"). Stop interval when no recent PI messages (e.g., 5 minutes idle).

    **manifest.json** — Add `"PropertyInspectorPath": "ui/global-settings.html"` at the plugin root level. This declares the global settings panel.
  </action>
  <verify>
    1. `npm run build` compiles without errors
    2. `manifest.json` contains `"PropertyInspectorPath": "ui/global-settings.html"`
    3. `ui/global-settings.html` exists and includes `sdpi-components.js` reference
    4. `src/plugin.ts` imports and loads ControllerRegistry before streamDeck.connect()
    5. `src/plugin.ts` handles all 5 message types: getControllers, addController, removeController, scan, addDiscovered
    6. The HTML includes scan button at top, controller list in middle, manual add form at bottom
    7. The HTML shows "Removing a controller may affect actions that reference it" note
    8. Empty scan results show "No WLED devices found" message
  </verify>
  <done>
    The global settings Property Inspector renders with scan/list/add sections per the locked layout decisions. The plugin backend handles all PI messages for CRUD and discovery. Controllers persist via global settings. The manifest declares the global settings panel. The full add/remove/scan workflow is wired end-to-end.
  </done>
</task>

</tasks>

<verification>
- `npm run build` exits with code 0
- Plugin entry point loads registry before connecting
- Global settings HTML has three sections: scan (top), list (middle), add (bottom)
- All PI-to-plugin message types handled
- manifest.json declares PropertyInspectorPath
</verification>

<success_criteria>
Users can open the WLED plugin's global settings in Stream Deck and: (1) scan for WLED devices on the network, (2) add controllers by IP/hostname with auto-fetched names, (3) see online/offline status, (4) remove controllers. All data persists across restarts via global settings.
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-03-SUMMARY.md`
</output>
